#!/usr/bin/env python3
# SPDX-License-Identifier: GPL-2.0-only
# Copyright (c) 2025 Fernando "ferabreu" Mees Abreu
#
# Licensed under the GNU General Public License v2.0 (GPL-2.0-only).
# See LICENSE file in the project root for full license information.
#
"""
This code was written and annotated by GitHub Copilot at the request of Fernando "ferabreu" Mees Abreu (https://github.com/ferabreu).

Simple dependency license scanner.

Scans installed Python packages and outputs license information to docs/dependency_licenses.md.

Usage:
  python scripts/check_licenses.py

Outputs:
  - docs/dependency_licenses.md
"""
import json
import re
import sys
import time
from pathlib import Path
from urllib import error, request

ROOT = Path(__file__).resolve().parents[1]
REQ_FILE = ROOT / "requirements.txt"
OUT_FILE = ROOT / "docs" / "dependency_licenses.md"
PYPI_URL = "https://pypi.org/pypi/{}/json"
NAME_RE = re.compile(r"^\s*([A-Za-z0-9_.+-]+)")


def parse_requirements(req_path):
    lines = []
    if not req_path.exists():
        print(f"requirements.txt not found at {req_path}", file=sys.stderr)
        return lines
    for raw in req_path.read_text().splitlines():
        s = raw.strip()
        if not s or s.startswith("#"):
            continue
        # skip VCS/local editable installs
        if s.startswith(("-e", "git+", "http://", "https://", "../", "./")):
            lines.append((s, None, "vcs_or_local"))
            continue
        m = NAME_RE.match(s)
        name = m.group(1) if m else s
        lines.append((s, name, "pkg"))
    return lines


def fetch_pypi_info(name):
    try:
        url = PYPI_URL.format(name)
        with request.urlopen(url, timeout=15) as resp:
            if resp.status != 200:
                return None
            return json.load(resp)
    except error.HTTPError as e:
        return {"error": f"HTTPError {e.code}"}
    except Exception as e:
        return {"error": str(e)}


def detect_gpl2_only(info):
    """
    Heuristic: check license field and classifiers for GPLv2.
    We mark as 'gpl2-only' if we see explicit GPLv2 classifier and no 'or later' hint.
    This is a best-effort heuristic; manual review recommended.
    """
    if not info or "info" not in info:
        return False, None
    info_block = info["info"]
    license_field = (info_block.get("license") or "").lower()
    classifiers = [c.lower() for c in info_block.get("classifiers") or []]

    # classifier exact match for GPL v2
    gpl2_classifier = any(
        "gnu general public license v2" in c or "gplv2" in c or "gpl v2" in c
        for c in classifiers
    )
    # look for 'or later' hints
    or_later = (
        any("or later" in c or "gpl v2 or later" in c for c in classifiers)
        or "or later" in license_field
    )

    # fallback: license_field mentions "gpl" and "2"
    license_text_hint = "gpl" in license_field and "2" in license_field

    is_gpl2_only = (gpl2_classifier and not or_later) or (
        license_text_hint and not or_later
    )
    return is_gpl2_only, {
        "license_field": info_block.get("license"),
        "classifiers": info_block.get("classifiers"),
    }


def main():
    rows = parse_requirements(REQ_FILE)
    if not rows:
        print("No requirements to process or requirements.txt missing.")
        return 2

    out_lines = [
        "# Dependency license report\n",
        "Generated by: scripts/check_licenses.py\n",
        "\n",
    ]
    summary = {"total": 0, "vcs_or_local": 0, "errors": 0, "gpl2_only": 0}

    for raw_line, name, kind in rows:
        summary["total"] += 1
        out_lines.append(f"## {raw_line}\n")
        if kind == "vcs_or_local":
            out_lines.append(
                "- Note: VCS or local entry; manual inspection required.\n\n"
            )
            summary["vcs_or_local"] += 1
            continue

        info = fetch_pypi_info(name)
        time.sleep(0.1)  # be kind to PyPI
        if info is None:
            out_lines.append(f"- Error: No PyPI package found for '{name}'.\n\n")
            summary["errors"] += 1
            continue
        if "error" in info:
            out_lines.append(f"- Error fetching PyPI info: {info['error']}\n\n")
            summary["errors"] += 1
            continue

        info_block = info.get("info", {})
        version = info_block.get("version")
        home_page = info_block.get("home_page") or info_block.get("project_url") or ""
        license_field = info_block.get("license") or ""
        classifiers = info_block.get("classifiers") or []

        gpl2_only, detect_meta = detect_gpl2_only(info)
        if gpl2_only:
            summary["gpl2_only"] += 1

        out_lines.append(f"- PyPI name: **{info_block.get('name')}**\n")
        out_lines.append(f"- Latest version on PyPI: {version}\n")
        if home_page:
            out_lines.append(f"- Home page: {home_page}\n")
        out_lines.append(f"- license field: `{license_field}`\n")
        if classifiers:
            out_lines.append("- Classifiers:\n")
            for c in classifiers:
                out_lines.append(f"  - `{c}`\n")
        out_lines.append(
            f"- GPLv2-only heuristic: **{'YES' if gpl2_only else 'no'}**\n\n"
        )

    out_lines.append("## Summary\n")
    out_lines.append(f"- Total entries processed: {summary['total']}\n")
    out_lines.append(f"- VCS/local entries: {summary['vcs_or_local']}\n")
    out_lines.append(f"- Fetch errors: {summary['errors']}\n")
    out_lines.append(
        f"- Packages flagged as GPLv2-only (heuristic): {summary['gpl2_only']}\n"
    )
    out_lines.append(
        "\n> Notes: This scanner uses heuristics based on PyPI metadata and classifiers. Manual review of any flagged packages is required to determine true license compatibility.\n"
    )

    OUT_FILE.parent.mkdir(parents=True, exist_ok=True)
    OUT_FILE.write_text("".join(out_lines))
    print(f"Wrote license report to {OUT_FILE}")
    print(
        "Manual next steps: review any flagged packages for 'GPL-2.0-only' vs 'GPL-2.0-or-later' and decide remediation."
    )
    return 0


if __name__ == "__main__":
    sys.exit(main())
